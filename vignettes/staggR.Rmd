---
title: "staggR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{staggR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

staggR: fit difference-in-differences models with staggered interventions
=====================

The `staggR` package fits linear difference-in-differences models in scenarios where intervention roll-outs are
staggered over time.  The package implements a version of an approach proposed by @sun_2021_estimating-dynamic estimates
cohort- and time-since-treatment specific difference-in-differences parameters. This package provides an alternative
approach that proceeds in two steps:

1. Estimate a difference-in-differences regression with cohort- and (calendar) time-specific parameters;

2. Translate difference-in-differences estimates into average estimates for arbitrary time periods relative to the
   intervention (e.g., post-intervention period).
   
By separating these two steps, we provide an easy-to-implement, transparent, intuitive difference-in-differences
framework.

# Background

Consider a scenario with $i=1,...,N$ units and $t=1,...,T$ periods. Units are exposed to the intervention at different
times. We group units having the intervention during the same time period into cohorts, which we denote by $c=1,...,C$. 
To simplify the notation, we assume that units in cohort $c=1$ are exposed to treatment at time $t=1$, etc. Units exposed to the intervention at time $t>T$ form the comparison group because they are not exposed to the intervention during the study period. 

Abraham and Sun's difference-in-differences specification interacts cohort indicators with time indicators relative to
intervention exposure start, and might be written as follows:

$$
y_{it} = \alpha_c D_c + \beta_t D_t + \left(\sum_c \sum_{l\neq -1} \gamma_{cl} D_c \cdot D^l_{it}\right) + \psi X_{it} + \varepsilon_{st},
$$

where $D_c$ are cohort indicators equal to one if unit $i$ is in cohort $c$ and zero otherwise, $D_t$ are time
indicators, and $D^l_{it}$ are indicators equal to one if unit $i$ is $l$ periods away from initial intervention
exposure, $X_{it}$ are covariates and $\varepsilon_{st}$ is the error term. The last pre-intervention period $l=-1$
is omitted to ensure identification. The parameters $\gamma_{cl}$ measure difference-in-differences estimates for a
cohort $c$ and time since intervention $l$.

Our approach recognizes the following relationship between time since intervention $l$ and time $t$, which was also
noted by Sun and Abraham:

$$
l = t-c 
$$

For instance, time $t=2$ for cohort $c=3$ is $l=-1$, i.e., the last period prior to intervention exposure,
because intervention exposure for cohort $c$ is $t=3$.

Using this insight, the difference-in-differences regression can alternatively be stated as follows:

$$
y_{it} = \alpha_c D_c + \beta_t D_t + \left(\sum_c \sum_{t\neq (c-1)} \gamma_{ct} D_c \cdot D_t\right) + \psi X_{it} + \varepsilon_{st}.
$$

Using this specification has two advantages:

1. It clarifies that this staggered difference-in-differences method is a generalization of the basic difference-in-differences design with
   two periods (a pre-intervention and a post-intervention period) and two cohorts (a treatment group and a comparison
   group).  In that setting, the indicator for the post-intervention period measures the change between the pre- and
   post-intervention period for the comparison group, and the difference-in-differences estimate measures the
   differential change between the pre- and post-intervention period for the treatment group.  
   
   The above equation preserves this structure, while showing how it is a more general version of the
   difference-in-differences design. Specifically, parameters $\beta_t$ measure changes over time for the comparison
   group, which now can include multiple periods; and parameters $\gamma_{ct}$ measure differential changes, but for
   multiple treatment cohorts instead of just one treatment group, and for multiple periods instead of just one.
   
2. It can be easily implemented in R (or other statistical programs) because it does not require constructing
   cohort-specific time since intervention indicators $D^l_{it}$. Instead, it uses cohort and time indicators and the
   interaction between the two. 
   
   
This packages provides functions to estimate such a difference-in-differences specification. It further provides
functions to translate difference-in-differences estimates into quantities that are useful for research purposes. For
instance, one can calculate average difference-in-differences estimates for each period relative to intervention
exposure, or one can calculate the average difference-in-differences estimates for the full post-intervention period.

[Should we add a brief description of how we aggregate coefficients to achieve the above? Or maybe that should go in the `sdid()` help file?]

# Example using simulated data

## Explore data

Consider as a didactic example a policy intervention designed to reduce inpatient hospitalizations in 15 counties. This longitudinal data set contains one row per individual-year. Each individual in the data set is identified by a globally unique identifier (`guid`), and we have measures of the individuals' ages, sexes, and comorbidities, and an indicator showing whether the individual was hospitalized during the current year. Each individual is also placed within a county, which itself is grouped into cohorts based on intervention year. Finally, the `yr` column indicates the year of the current observation. 

```{r setup}
library(staggR)
head(hosp, 20)
```

If `intervention_yr` is `NA`, we can conclude that the county never implemented the intervention. We observe that, among the 15 counties in the data set, 3 counties implemented the intervention in 2015; 2 counties implemented in 2016; 5 counties implemented in 2017; 1 county implemented in 2018; and 4 counties did not implement the intervention at all during the study period.

```{r}
with(hosp,
     table(county, intervention_yr, useNA = "ifany"))
```

Counties are organized into cohorts by intervention year. All counties having the same intervention year are assigned to the same cohort.

```{r}
county_cohorts <- unique(hosp[, c("county", "cohort", "intervention_yr")])
county_cohorts[order(county_cohorts$cohort), ]
```


The study period runs for 11 years, from 2010 through 2020. 

```{r}
with(hosp,
     table(county, yr))
```

Hospitalizations occurred in every county-year. 

```{r}
stats::xtabs(hospitalized ~ county + yr, 
             data = hosp)
```

We can create a time-series plot to visualize the proportion of individuals who were hospitalized over time.

```{r tsplot, fig.width = 10, fig.height = 6, out.width = "100%"}
ts_plot(hospitalized ~ county + yr,
        df = hosp,
        intervention_var = "intervention_yr")
```

This is helpful, but all of the counties that didn't implement the intervention have been omitted from the plot. This is because `ts_plot()` omits any counties where any of the elements in the formula above (`hospitalized ~ county + yr`) or the `intervention_var` are `NA`. 

```{r}
table(hosp$hospitalized, useNA = "always")
table(hosp$county, useNA = "always")
table(hosp$yr, useNA = "always")
table(hosp$intervention_yr, useNA = "always")
```

Of course, `intervention_yr` is the culprit, because we have some counties that never implemented the intervention. We can add these counties back to the plot if we change these `NA`s to some other string to indicate that they did not intervene.

```{r tsplot2, fig.width = 10, fig.height = 6, out.width = "100%"}
hosp2 <- hosp
hosp2$intervention_yr <- ifelse(is.na(hosp2$intervention_yr),
                                yes = "Comparison group",
                                no = hosp2$intervention_yr)
county_plot <- ts_plot(hospitalized ~ county + yr,
                       df = hosp2,
                       intervention_var = "intervention_yr")
county_plot
```

It might be easier to compare the panels in this plot if the X axes were all aligned at the point of intervention. We can accomplish this by passing a time-since-intervention (`tsi`) object to `ts_plot()`. We create a `tsi` object by passing the `hosp2` data set to the `id_tsi()` function, and we identify the names of the columns that contain intervention cohorts, time periods, and the time period during which each cohort implemented the intervention. The returned `tsi` object contains a data frame, which includes columns `cohort`, `time`, `intervention_time`, and `tsi`. Each row corresponds to a unique county-time period. The `tsi` column contains an integer that tells us how many time periods the corresponding time period is away from the intervention. For example, Ashbrook County belongs to cohort 5, which means the intervention took place in 2015. If we examine the first row of the `tsi` object, we'll see that the time period 2010 is 5 time periods prior to the intervention, so `tsi` has a value of -5. Values of `tsi` are negative and arrive at 0 during the year of intervention, and then they are positive in the years following the intervention. 

```{r}
hosp_tsi <- id_tsi(df = hosp2,
                        cohort_var = "county",
                        time_var = "yr",
                        intervention_var = "intervention_yr")
head(hosp_tsi$data, 11)
```

Now we can pass `hosp_tsi` to `ts_plot()` to generate a set of plots with time since intervention on the X axis instead of years. 

```{r tsplot3, fig.width = 10, fig.height = 6, out.width = "100%"}
county_plot <- ts_plot(hospitalized ~ county + yr,
        df = hosp2,
        intervention_var = "intervention_yr", 
        tsi = hosp_tsi)
county_plot
```

We might like to customize this plot a little bit and use better labels for the X and Y axes. Fortunately, `ts_plot()` returns a `ggplot` object, so we can append any `ggplot2` functions to customize the plot.

```{r tsplot4, fig.width = 10, fig.height = 6, out.width = "100%"}
library(ggplot2)
county_plot +
  scale_x_continuous(name = "Years", 
                   breaks = seq(-8, 5, by = 2)) +
  scale_y_continuous(name = "Percent hospitalized",
                     breaks = seq(0, 1, by = 0.2),
                     labels = scales::percent_format()) +
  theme_classic() +
  theme(panel.grid.major.x = element_line(linewidth = 0.5))
```

## Fit model

Now that we have some familiarity with the data, we can fit a staggered difference-in-differences model. The order of terms in the regression formula is important: `sdid()` will assume that the first term on the right-hand side of the formula is the variable identifies cohorts, and the second term is the variable that identifies the time period that each observation comes from. All remaining terms on the right-hand side of the formula are covariates that we would like to use to adjust our model. The dependent variable is on the left-hand side of the formula, as usual.

Importantly, we also tell `sdid()` the name of the column that contains the time period during which each cohort implemented the intervention. In our case, that column is called `intervention_yr`. 

```{r}
sdid_hosp <- sdid(hospitalized ~ cohort + yr + age + sex + comorb,
                  df = hosp,
                  intervention_var  = "intervention_yr")
```

Although we supplied a formula to fit this model, it's important to recognize that this formula is specified according to a convenience syntax, which assumes that we want to fit an Abrams and Sun-style staggered difference-in-differences model, as defined in the Background section above, rather than the very simple model implied by our formula. If we would like to see the formula passed to `lm()` to fit the staggered difference-in-differences model, we can examine the components of the `sdid_hosp` object.

```{r}
names(sdid_hosp)
sdid_hosp$formula
```

Here we see both the `supplied` and `fitted` formulas. The `fitted` formula includes main effects for each cohort and time period and interaction terms for each cohort-time period combination. You might notice that these terms do not exist in our supplied data.frame; this is because `sdid()` calls `prep_data()` to create all necessary dummy variables. These are needed because we have to be very explicit about which levels of each cohort and time period variable are used as referents in the model, and these referent levels differ for main effects and for each set of interaction terms. 

By default, `sdid()` assumes that the first observed levels of both the cohort column and the time-period column should function as the referents for the main effects. This is the same as with `lm()` and most other modeling functions in R. For the long list of cohort-time period interactions, however, `sdid()` assumes that the time period immediately preceding the intervention time period (defined by `intervention_var`) should be the referent. In this case, that means that the interaction terms for `cohort_5` should omit 2014 as the referent time period, because that cohort's intervention took place in 2015. Similarly, the interaction terms for `cohort_6` should omit 2015 as the referent time period, because that cohort's intervention took place in 2016. Indeed, we observe that the formula has interaction terms `cohort_5:yr_2010` through `cohort_5:yr_2020`, with `cohort_5_2014` omitted for identification. 

If, for some reason, we wanted a different time period to function as the referent, we could specify that using the `cohort_time_refs` argument.

```{r}
sdid_hosp_earlier_timeref <- sdid(hospitalized ~ cohort + yr + age + sex + comorb,
                  df = hosp,
                  cohort_time_refs = list(`5` = "2013",
                                          `6` = "2014",
                                          `7` = "2015",
                                          `8` = "2016"),
                  intervention_var  = "intervention_yr")
summary(sdid_hosp_earlier_timeref)
```

If we want standard errors clustered at the county level, we might specify that we want to use the clustered covariance matrix estimation function from the `sandwich` package. 

```{r}
sdid_hosp <- sdid(hospitalized ~ cohort + yr + age + sex + comorb,
                  df = hosp,
                  intervention_var  = "intervention_yr",
                  .vcov = sandwich::vcovCL,
                  cluster = hosp$county)
summary(sdid_hosp)
```

This works, but our research question is really about how the intervention affected hospitalizations overall during the post-intervention period, across all cohorts. To answer that question, we will need to aggregate some of the coefficients from the model summary.

## Calculating coefficient averages

The `ave_coeff()` function makes it easy to calculate averages of any specified set of regression coefficients, while also returning aggregated standard errors. 


